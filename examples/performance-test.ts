/**\n * Performance testing and benchmarking examples\n */\n\nimport { MessageBrokerFactory, UniversalMessageManager } from '../src';\nimport Redis from 'ioredis';\n\ninterface BenchmarkResult {\n  broker: string;\n  operation: string;\n  messageCount: number;\n  duration: number;\n  throughput: number;\n  avgLatency: number;\n  p95Latency: number;\n  p99Latency: number;\n  errorRate: number;\n}\n\nclass PerformanceTester {\n  private results: BenchmarkResult[] = [];\n\n  async benchmarkPublishing(\n    manager: UniversalMessageManager,\n    messageCount: number = 10000\n  ): Promise<BenchmarkResult> {\n    const topic = 'benchmark.publish';\n    const latencies: number[] = [];\n    let errors = 0;\n\n    console.log(`Starting publish benchmark: ${messageCount} messages`);\n    const startTime = Date.now();\n\n    for (let i = 0; i < messageCount; i++) {\n      const msgStart = Date.now();\n      try {\n        await manager.publishImmediate(topic, {\n          id: i,\n          timestamp: Date.now(),\n          data: `Message ${i}`,\n          payload: new Array(100).fill('x').join(''), // ~100 bytes\n        });\n        latencies.push(Date.now() - msgStart);\n      } catch (error) {\n        errors++;\n      }\n\n      // Progress indicator\n      if (i % 1000 === 0) {\n        process.stdout.write(`\\rProgress: ${i}/${messageCount}`);\n      }\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    const throughput = messageCount / (duration / 1000);\n\n    latencies.sort((a, b) => a - b);\n    const avgLatency = latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length;\n    const p95Latency = latencies[Math.floor(latencies.length * 0.95)];\n    const p99Latency = latencies[Math.floor(latencies.length * 0.99)];\n    const errorRate = (errors / messageCount) * 100;\n\n    console.log(`\\nPublish benchmark completed`);\n\n    return {\n      broker: manager.getBrokerType(),\n      operation: 'publish',\n      messageCount,\n      duration,\n      throughput,\n      avgLatency,\n      p95Latency,\n      p99Latency,\n      errorRate,\n    };\n  }\n\n  async benchmarkSubscription(\n    manager: UniversalMessageManager,\n    messageCount: number = 10000\n  ): Promise<BenchmarkResult> {\n    const topic = 'benchmark.subscribe';\n    const receivedMessages: number[] = [];\n    let receivedCount = 0;\n    let errors = 0;\n\n    console.log(`Starting subscription benchmark: ${messageCount} messages`);\n\n    // Subscribe to messages\n    const subscriptionPromise = new Promise<void>((resolve) => {\n      manager.subscribe(topic, (message) => {\n        try {\n          receivedMessages.push(Date.now());\n          receivedCount++;\n          \n          if (receivedCount >= messageCount) {\n            resolve();\n          }\n        } catch (error) {\n          errors++;\n        }\n      });\n    });\n\n    // Wait a bit for subscription to be ready\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Start publishing messages\n    const startTime = Date.now();\n    const publishPromises = [];\n\n    for (let i = 0; i < messageCount; i++) {\n      publishPromises.push(\n        manager.publishImmediate(topic, {\n          id: i,\n          timestamp: Date.now(),\n          data: `Message ${i}`,\n        })\n      );\n    }\n\n    // Wait for all messages to be published and received\n    await Promise.all(publishPromises);\n    await subscriptionPromise;\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    const throughput = receivedCount / (duration / 1000);\n    const errorRate = (errors / messageCount) * 100;\n\n    console.log(`Subscription benchmark completed`);\n\n    return {\n      broker: manager.getBrokerType(),\n      operation: 'subscribe',\n      messageCount: receivedCount,\n      duration,\n      throughput,\n      avgLatency: 0, // Not applicable for subscription\n      p95Latency: 0,\n      p99Latency: 0,\n      errorRate,\n    };\n  }\n\n  async benchmarkRoundTrip(\n    manager: UniversalMessageManager,\n    messageCount: number = 1000\n  ): Promise<BenchmarkResult> {\n    const topic = 'benchmark.roundtrip';\n    const latencies: number[] = [];\n    let completedCount = 0;\n    let errors = 0;\n\n    console.log(`Starting round-trip benchmark: ${messageCount} messages`);\n\n    // Subscribe to echo messages\n    await manager.subscribe(topic, async (message) => {\n      try {\n        // Echo the message back\n        await manager.publishImmediate(`${topic}.echo`, {\n          ...message.payload,\n          echoTime: Date.now(),\n        });\n      } catch (error) {\n        errors++;\n      }\n    });\n\n    const startTime = Date.now();\n    const promises: Promise<void>[] = [];\n\n    for (let i = 0; i < messageCount; i++) {\n      const promise = new Promise<void>((resolve) => {\n        const msgStart = Date.now();\n        \n        // Subscribe to echo response\n        manager.subscribe(`${topic}.echo`, (echoMessage) => {\n          if (echoMessage.payload.id === i) {\n            latencies.push(Date.now() - msgStart);\n            completedCount++;\n            resolve();\n          }\n        });\n\n        // Send original message\n        manager.publishImmediate(topic, {\n          id: i,\n          timestamp: msgStart,\n          data: `Round-trip message ${i}`,\n        });\n      });\n\n      promises.push(promise);\n    }\n\n    await Promise.all(promises);\n\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    const throughput = completedCount / (duration / 1000);\n\n    latencies.sort((a, b) => a - b);\n    const avgLatency = latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length;\n    const p95Latency = latencies[Math.floor(latencies.length * 0.95)];\n    const p99Latency = latencies[Math.floor(latencies.length * 0.99)];\n    const errorRate = (errors / messageCount) * 100;\n\n    console.log(`Round-trip benchmark completed`);\n\n    return {\n      broker: manager.getBrokerType(),\n      operation: 'round-trip',\n      messageCount: completedCount,\n      duration,\n      throughput,\n      avgLatency,\n      p95Latency,\n      p99Latency,\n      errorRate,\n    };\n  }\n\n  printResults(): void {\n    console.log('\\n=== Performance Benchmark Results ===\\n');\n    \n    this.results.forEach(result => {\n      console.log(`${result.broker.toUpperCase()} - ${result.operation.toUpperCase()}`);\n      console.log(`  Messages: ${result.messageCount.toLocaleString()}`);\n      console.log(`  Duration: ${result.duration.toLocaleString()}ms`);\n      console.log(`  Throughput: ${result.throughput.toFixed(2)} msg/sec`);\n      \n      if (result.avgLatency > 0) {\n        console.log(`  Avg Latency: ${result.avgLatency.toFixed(2)}ms`);\n        console.log(`  P95 Latency: ${result.p95Latency.toFixed(2)}ms`);\n        console.log(`  P99 Latency: ${result.p99Latency.toFixed(2)}ms`);\n      }\n      \n      console.log(`  Error Rate: ${result.errorRate.toFixed(2)}%`);\n      console.log('');\n    });\n  }\n\n  async runFullBenchmark(): Promise<void> {\n    const manager = await MessageBrokerFactory.createRedis('localhost', 6379, Redis);\n    await manager.connect();\n\n    try {\n      // Run benchmarks\n      this.results.push(await this.benchmarkPublishing(manager, 5000));\n      this.results.push(await this.benchmarkSubscription(manager, 5000));\n      this.results.push(await this.benchmarkRoundTrip(manager, 500));\n\n      // Print results\n      this.printResults();\n\n      // Print system metrics\n      const metrics = manager.getPerformanceMetrics();\n      console.log('=== System Metrics ===');\n      console.log(JSON.stringify(metrics, null, 2));\n\n    } finally {\n      await manager.disconnect();\n    }\n  }\n}\n\n// Memory usage monitoring\nfunction monitorMemory(): void {\n  const usage = process.memoryUsage();\n  console.log('Memory Usage:');\n  console.log(`  RSS: ${(usage.rss / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`  Heap Used: ${(usage.heapUsed / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`  Heap Total: ${(usage.heapTotal / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`  External: ${(usage.external / 1024 / 1024).toFixed(2)} MB`);\n}\n\n// Run performance tests\nif (require.main === module) {\n  const tester = new PerformanceTester();\n  \n  console.log('Starting performance benchmarks...');\n  monitorMemory();\n  \n  tester.runFullBenchmark()\n    .then(() => {\n      console.log('\\nBenchmarks completed!');\n      monitorMemory();\n    })\n    .catch(console.error);\n}